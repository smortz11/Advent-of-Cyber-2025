TryHackMe's eleventh day of Advent of Cyber is among us! Today, we will be covering cross-site scripting. The objectives of the room will teach us how XSS works and how to prevent them in our webapps. Let's start the AttackBox and VM and begin!

XSS is a vulnerability that occurs when user input is accepted into a server without being sanitized. Most of the time, it is JavaScript code that is being submitted. XSS is categorized into many categories, including, but not limited to, reflected and stored XSS. 

Reflected XSS is demonstrated when an inject is immediately projected in a response. This can be done by embedding JavaScript into various fields in a URL. 

Stored XSS stores malicious scripts on a server and loads it for users who visit the page. While reflected XSS can target specific individuals, stored xss is more broad and can affect any person who views the site.

There are several ways to eliminate XSS vulnerabilities such as:
1. Disable dangerous rendering raths (textContent over innerHTML)
2. Make cookies inaccessible to JS (HttpOnly, Secure, SameSite)
3. Sanitize input/output and encode

A simple way of testing for reflected XSS would be inputting JavaScript into a textbox, like `<script>alert('an alert')</script>`. If the input box is vulnerable, an alert would show on our browser.

User input, such as searching for something in a database, would not count as stored XSS, instead as reflected XSS, since the query is not being stored and reaccessed another time. However, if we are sending a message, we may be able to inject a similar prompt, which would activate for everybody who accesses that input in the database.

### Q1: Which type of XSS attacks requires payloads to be persisted on the backend?
Differences are discussed above.

### Q2: What's the reflected XSS flag?
Perform reflected XSS and the flag will appear.

### Q3: What's the stored XSS flag?
Perform stored XSS and the flag will appear.